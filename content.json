{"pages":[{"title":"","text":"sdfsf","link":"/blog/about/index.html"}],"posts":[{"title":"面试题","text":"深拷贝 JSON.parse(JSON.stringify())—–会忽略undefined(丢失这个结构)，不能序列化函数(丢失这个结构) loadsh cloneDeep 浅拷贝 Object.assign 扩展运算符 原型 flex flex:1 表示：flex-grow:1;flex-shrink:1,flex-basis:0% flex-grow 属性用于设置或检索弹性盒子的扩展比率 flex-shrink:指定了 flex 元素的收缩规则 flex-basis:属性用于设置或检索弹性盒伸缩基准值 es5继承 防抖 当事件被触发时，设定一个周期延迟执行动作，若期间又被触发，则重新设定周期，直到周期结束，执行动作。如何用代码写出来？ 123456789101112const handle = (function(){ let tid = null; return function(value){ clearTimeout(tid) tid = setTimeout(()=&gt;{ console.log(value) },1000) } })() const handlechange = ({value})=&gt;{ handle(value) } 节流 当事件快速连续不断触发时，动作只会执行一次。 延迟debounce，是在周期结束时执行，前缘debounce，是在周期开始时执行。但当触发有间断，且间断大于我们设定的时间间隔时，动作就会有多次执行。如何用代码写出来 12345678910111213const handle = (function(){ let tid = null; return function(value){ if(tid) return; tid = setTimeout(()=&gt;{ console.log(value) tid = null },500) }})()const handlechange = ({value})=&gt;{ handle(value)} 数组去重 Array.from(new Set(arr)) arr.filter((item,index)=&gt;arr.inexOf(item)==index) arr.forEach(item=&gt;!data.includes(item) &amp;&amp; data.push(item)) 利用对象去重 文字颜色一半一半(没有效果) color:transparent; background:linear-gradient(to right,#ccc, #000); -webkit-background-clip:text; css三角形底20px 高10px 的red三角形 width:0;height:0;border-bottom:10px solid red;border-left:10px solid transparent;border-right:10px solid transparent; fetch是否可以取消请求（可以） 1234567891011121314let controller = new AbortController();let signal = controller.signal;fetch(url, { signal: controller.signal});signal.addEventListener('abort', () =&gt; console.log('abort!'));controller.abort(); // 取消console.log(signal.aborted); // true 闭包:定义在一个函数内部的函数作用：保护函数内变量的安全在内存中维持一个变量 react生命周期constructor()componentWillMount()componentDidMount()render()shouldComponentUpdate()componentWillUpdate()componentDidUpdate()render()componentWillUnmount() less常用语法变量 @width:10px; @height:@width+10px;运算 + - * / 加减之前会做单位转化，计算结果以最左侧的操作数单位类型为准。乘法除法不做转换。一个长度乘以一个长度得到一个区域，而css是不支持指定区域的。还可以对颜色进行算数运算 hooks和class的区别 react内存溢出 useEffect和useLayoutEffect this.setState在任何状态下都是异步的吗当直接调用时this.setState时，为异步更新；当在异步函数的回调中调用this.setState，则为同步更新；当放在自定义 DOM 事件的处理函数中时，也是同步更新 性能优化 diff算法在某一时间节点调用 React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。官方文档的diff解释总结一下 当对比两棵树时，React 首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态。 对比同一类型的元素当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。 对比同类型的组件元素当一个组件更新时，组件实例会保持不变，因此可以在不同的渲染时保持 state 一致 对子节点进行递归 symbol表示独一无二的值，最大的用法是用来定义对象的唯一属性名 接口跨域jsonp利用script标签可跨域来实现。缺点：只能发送get请求nginx反向代理 判断对象是否是数组Array.isArray()a instanceof ArrayObject.prototype.toString.call(a) == ‘[object Array]’ 判断是否为对象Object.prototype.toString.call(a) == ‘[object Object]’ 是否是空对象JSON.stringfy({}) == ‘{}’for in 循环判断Object.keys({}).length == 0 git rebase和merge的区别 1px的实现 给div加边框(不用border)outline:#00FF00 dotted thick; 不会占据空间 ios时间 Date() 兼容问题 flex的缺点：浏览器兼容性比较差，只能兼容到ie9及以上 移动端的兼容性及解决 文字一行，查出省略号显示white-space:nowrap;overflow:hidden;text-overflow:ellipsis; 两行text-overflow: ellipsis;display: -webkit-box; -webkit-line-clamp: 2; overflow: hidden; /*! autoprefixer: off / -webkit-box-orient: vertical; /! autoprefixer: on */ animation和transition的区别 元素居中flexabsolute 弹窗组件实现思路 nginx rem如果ui稿750px,分成7.5份，每份100px , 设计稿px/100即可得到多少rem屏幕375px,分成7.5份，每份50px,所以fontSize=50px html根节点 em相对与当前字体的fontSize vw vhvw视口宽度vh视口高度 hash 路由：监听 url 中 hash 的变化，然后渲染不同的内容，这种路由不向服务器发送请求，不需要服务端的支持；history 路由：监听 url 中的路径变化，需要客户端和服务端共同的支持 new 对象 手写 原型 原型链 进程：进程是cpu资源分配的最小单位（是拥有资源和独立运行的最小单位）线程：线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程） 浏览器的渲染进程是多线程的。主要有一下几个线程。1、GUI渲染线程2、js引擎执行线程3、事件触发线程（将异步任务放入队列中，排队等待js引擎执行线程）4、定时器触发器线程。（因为js引擎是单线程的，如果处于阻塞线程状态就会影响即使的准确性）5、异步http请求线程 浏览器渲染流程：1、解析html建立dom树2、解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）3、布局render树（Layout/reflow），负责各元素尺寸、位置的计算4、绘制render树（paint），绘制页面像素信息5、浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。 事件循环机制JS引擎是单线程，负责执行JS代码的。1、主线程运行时会产生执行栈，栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）2、而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调如此循环注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件 左右布局 快速排序 受控组件如果一个 input 表单元素的值是由 React 控制，就其称为受控组件。当用户将数据输入到受控组件时，会触发修改状态的事件处理器，这时由你的代码来决定此输入是否有效（如果有效就使用更新后的值重新渲染）。如果不重新渲染，则表单元素将保持不变。 非受控组件一个非受控组件，就像是运行在 React 体系之外的表单元素。当用户将数据输入到表单字段（例如 input：file，dropdown 等）时，React 不需要做任何事情就可以映射更新后的信息。然而，这也意味着，你无法强制给这个表单字段设置一个特定值 import require的区别 cmd amdAMD 推崇依赖前置CMD 推崇就近依赖 AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块。 兼容问题1、ios时间对象2、ios左右滑动会有回弹效果，如果没有等滑动停止，立即改变容器布局，容器内的元素会消失 get、post的区别 浏览器缓存 原型可以解决什么问题？对象共享属性和共享方法 谁拥有原型函数拥有:prototype对象拥有：proto 对象查找属性或者方法的顺序先在对象本身查找==&gt;到构造函数查找==&gt;对象的原型查找==&gt;构造函数的原型查找==&gt;当前原型的原型中查找 原型链是什么？ 就是把原型串联起来原型链的顶端是null 延迟加载JS有哪些方式async deferasync和defer的区别async: 异步下载，下载完成之后立即执行。无序执行，谁先加载完谁先执行defer: 异步下载，解析完所有html之后顺序执行 数据类型7种基本数据类型和对象7种基本数据类型：string number boolean bigint null undefined symbol NaN是一个数值类型，但是不是一个具体的数字true+1 //2字符串和其它类型相加，其它类型都被转为字符串 undefined+1 //NaNtypeof(undefined+1) //numbertypeof(NaN) //numbertypeof(undefined) //undefinedtypeof(null) //ObjectNaN == NaN //false null和undefined的区别？先设计的null，后设计的undefinednull是一个表示“无”的对象转化为数值时为0null是一个表示“无”的原始值，转化为数值时为NaN ==和=== 的区别==： 比较值===：比较值，还比较类型 string == number || boolean ||…都会隐式转换为基本类型对象=&gt;字符串=&gt;数值布尔=&gt;shuzhinull == undefined //true 1==’1’ //truetrue==1 //true[1,2]==’1,2’ //true 微任务和宏任务js是单线程的语言JavaScript 语言的一大特点就是单线程，也就是说．同一个时间只能做一件事。那么，为什么 Javascript 不能有多个线程呢 ？这样能提高效率啊Javascript 的单线程，与亡的用途有关．作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM. 这决定了它只能是单线程，否则会带米很复杂的同步问题．比如，假定 JavaScript 同时有两个线程，个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这己经成了这门语言的核心特征，将来也不会改变 for(var i=0;i&lt;3;i++&gt;){ setTimeout(function(){ console.log(i) },1000*i)}// 3 3 3 for(let i=0;i&lt;3;i++){ setTimeout(function(){ console.log(i) },1000*i)}//0 1 2 微任务 promise.then宏任务 setTimeout…要执行宏任务的前提是清空了所有的微任务流程： 同步==&gt; 事件循环【微任务和宏任务】 JS作用域var1、除了函数外，js是没有块级作用域的2、作用域链：内部可以访问外部的变量，但是外部不能访问内部的变量 let const 具有块级作用域 (function(){ var a = b =10 //window.b})()console.log(a) //报错console.log(b) //10 function c(){ var b = 1; function a(){ console.log(b) var b = 2; console.log(b) } a(); console.log(b)}c(); //打印undefined21 3、注意：js有变量提升的机制【变量悬挂声明】 var name = ‘a’(function(){ if(typeof name == undefined){ var name = ‘b’ console.log(‘1111’+name) }else{ console.log(‘222’+name) }})()//1111b 4、优先级：声明变量&gt;声明普通函数&gt;参数&gt;变量提升普通声明函数是不看函数定义的顺序function fun(a){ var a = 10; function a(){} console.log(a)} fun(100) //10 JS对象对象如果找属性|方法；对象本生找==&gt;构造函数中找==&gt;对象原型中找==&gt;构造函数原型中找==&gt;对象上一层原型中找 判断是否为数组const a = []方式一：Array.isArray(a)方式二：a instanceof Array方式三：Object.prototype.toString.call(a).indexOf(‘Array’)&gt;-1方式四：Array.prototype.isPrototypeOf(arr)方式五：a.constructor.toString().indexOf(‘Array’)&gt;-1 slice,splice[string | array].slice(?start,?end) 截取，不改变原值,返回新值array.splice(?start,deleteCount,…items) 插入、删除、替换，会改变原数组 找出多维数组中的最大值let arr = [[4,23,35,1],[1,33,5,23,333],[2323,4,1,2]] let newArr = []for(let i of arr){newArr.push(Math.max(…i))} 给数组新增方法String.prototype.addPrefix = function(str){return str+this;} 找出字符串中出现最多次数的字符及次数const str = ‘aaaaaaaaawffffffffffwefffffwefbbb’const obj = {}for(let i =0;i&lt;str.length;i++){const char = str[i] if(obj[char]){ obj[char]++; }else{ obj[char]=1; } }let max=0;for(let key in obj){if(max&lt;obj[key]){max=obj[key] }} for(let key in obj){ if(obj[key]==max){ console.log(‘出现最多的字符是’+key) break; }} new 操作符具体做了什么1、创建了一个空的对象2、将空对象的原型，指向于构造函数的原型3、将空对象作为构造函数的上下文（改变this指向）4、对构造函数有返回值的做处理判断 function Foo(){}new Foo().prototype == Foo.prototype //true 闭包1、闭包是什么闭包是一个函数加上到创建函数的作用域的连接2、闭包可以解决什么问题(优点)3、闭包的缺点变量会驻留在内存中，造成内存损耗问题。内存泄漏（ie） function fun(){ let a = 10 return function(){ a++ console.log(a) }} fun()(); JS继承有哪些方式1、ES6 class2、原型链继承3、借用构造函数的形式 sort的用法默认unicode排序 var、let、const的区别1、var具有变量提升的机制let、const没有变量提升机制2、var 可以多次声明同一个变量let不可以多次声明同一个变量3、var、let声明变量的const 声明常量 箭头函数和普通函数有什么区别1、this指向箭头函数中的this是在箭头函数定义时就决定的箭头函数的this指向定义时候，外层第一个普通函数的this let obj ={ a: function(){ console.log(this) } b:()=&gt;{ console.log(this) }}obj.a() //objobj.b() //window let obj = { run:function(){ return function(){ console.log(this) } }}obj.run()() //window2、箭头函数不能new(不能当作构造函数)3、没有prototype4、没有arguments 伪类和伪元素的区别","link":"/blog/2021/06/01/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"分享一些写的很好的文章","text":"useEffect 完整指南 — Overreacted When (and when not) to reach for Redux","link":"/blog/2021/06/01/%E5%88%86%E4%BA%AB%E4%B8%80%E4%BA%9B%E5%86%99%E7%9A%84%E5%BE%88%E5%A5%BD%E7%9A%84%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"react","slug":"react","link":"/blog/tags/react/"}],"categories":[]}