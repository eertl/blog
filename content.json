{"pages":[{"title":"","text":"sdfsf","link":"/blog/about/index.html"}],"posts":[{"title":"面试题","text":"深拷贝 JSON.parse(JSON.stringify())—–会忽略undefined(丢失这个结构)，不能序列化函数(丢失这个结构) loadsh cloneDeep 浅拷贝 Object.assign 扩展运算符 原型 flex flex:1 表示：flex-grow:1;flex-shrink:1,flex-basis:0% flex-grow 属性用于设置或检索弹性盒子的扩展比率 flex-shrink:指定了 flex 元素的收缩规则 flex-basis:属性用于设置或检索弹性盒伸缩基准值 es5继承 防抖 当事件被触发时，设定一个周期延迟执行动作，若期间又被触发，则重新设定周期，直到周期结束，执行动作。如何用代码写出来？ 节流 当事件快速连续不断触发时，动作只会执行一次。 延迟debounce，是在周期结束时执行，前缘debounce，是在周期开始时执行。但当触发有间断，且间断大于我们设定的时间间隔时，动作就会有多次执行。如何用代码写出来 数组去重 Array.from(new Set(arr)) arr.filter((item,index)=&gt;arr.inexOf(item)==index) arr.forEach(item=&gt;!data.includes(item) &amp;&amp; data.push(item)) 利用对象去重 文字颜色一半一半(没有效果) color:transparent; background:linear-gradient(to right,#ccc, #000); -webkit-background-clip:text; css三角形底20px 高10px 的red三角形 width:0;height:0;border-bottom:10px solid red;border-left:10px solid transparent;border-right:10px solid transparent; fetch是否可以取消请求（可以）let controller = new AbortController();let signal = controller.signal; fetch(url, { signal: controller.signal}); signal.addEventListener(‘abort’, () =&gt; console.log(‘abort!’)); controller.abort(); // 取消 console.log(signal.aborted); // true 闭包:定义在一个函数内部的函数作用：保护函数内变量的安全 在内存中维持一个变量 react生命周期constructor()componentWillMount()componentDidMount()render()shouldComponentUpdate()componentWillUpdate()componentDidUpdate()render()componentWillUnmount() less常用语法变量 @width:10px; @height:@width+10px;运算 + - * / 加减之前会做单位转化，计算结果以最左侧的操作数单位类型为准。 乘法除法不做转换。一个长度乘以一个长度得到一个区域，而css是 不支持指定区域的。还可以对颜色进行算数运算 hooks和class的区别 react内存溢出 useEffect和useLayoutEffect this.setState在任何状态下都是异步的吗当直接调用时this.setState时，为异步更新；当在异步函数的回调中调用this.setState，则为同步更新；当放在自定义 DOM 事件的处理函数中时，也是同步更新 性能优化 diff算法 symbol表示独一无二的值，最大的用法是用来定义对象的唯一属性名 接口跨域jsonp 利用script标签可跨域来实现。缺点：只能发送get请求 nginx反向代理 判断对象是否是数组Array.isArray()a instanceof ArrayObject.prototype.toString.call(a) == ‘[object Array]’ 判断是否为对象Object.prototype.toString.call(a) == ‘[object Object]’ 是否是空对象JSON.stringfy({}) == ‘{}’for in 循环判断Object.keys({}).length == 0 git rebase和merge的区别 1px的实现 给div加边框(不用border)outline:#00FF00 dotted thick; 不会占据空间 ios时间 Date() 兼容问题 flex的缺点：浏览器兼容性比较差，只能兼容到ie9及以上 移动端的兼容性及解决 文字一行，查出省略号显示white-space:nowrap;overflow:hidden;text-overflow:ellipsis; 两行text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; overflow: hidden; /*! autoprefixer: off */ -webkit-box-orient: vertical; /*! autoprefixer: on */ animation和transition的区别 元素居中flexabsolute 弹窗组件实现思路 nginx rem如果ui稿750px,分成7.5份，每份100px , 设计稿px/100即可得到多少rem屏幕375px,分成7.5份，每份50px,所以fontSize=50px html根节点 em相对与当前字体的fontSize vw vhvw视口宽度vh视口高度 hash 路由：监听 url 中 hash 的变化，然后渲染不同的内容，这种路由不向服务器发送请求，不需要服务端的支持；history 路由：监听 url 中的路径变化，需要客户端和服务端共同的支持 new 对象 手写 原型 原型链 进程：进程是cpu资源分配的最小单位（是拥有资源和独立运行的最小单位）线程：线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程） 浏览器的渲染进程是多线程的。主要有一下几个线程。1、GUI渲染线程2、js引擎执行线程3、事件触发线程（将异步任务放入队列中，排队等待js引擎执行线程）4、定时器触发器线程。（因为js引擎是单线程的，如果处于阻塞线程状态就会影响即使的准确性）5、异步http请求线程 浏览器渲染流程：1、解析html建立dom树2、解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）3、布局render树（Layout/reflow），负责各元素尺寸、位置的计算4、绘制render树（paint），绘制页面像素信息5、浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。 事件循环机制JS引擎是单线程，负责执行JS代码的。1、主线程运行时会产生执行栈，栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）2、而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调如此循环注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件 左右布局 快速排序 受控组件如果一个 input 表单元素的值是由 React 控制，就其称为受控组件。当用户将数据输入到受控组件时，会触发修改状态的事件处理器，这时由你的代码来决定此输入是否有效（如果有效就使用更新后的值重新渲染）。如果不重新渲染，则表单元素将保持不变。 非受控组件一个非受控组件，就像是运行在 React 体系之外的表单元素。当用户将数据输入到表单字段（例如 input：file，dropdown 等）时，React 不需要做任何事情就可以映射更新后的信息。然而，这也意味着，你无法强制给这个表单字段设置一个特定值 import require的区别 cmd amd 兼容问题1、ios时间对象2、ios左右滑动会有回弹效果，如果没有等滑动停止，立即改变容器布局，容器内的元素会消失","link":"/blog/2021/06/01/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"title":"分享一些写的很好的文章","text":"useEffect 完整指南 — Overreacted When (and when not) to reach for Redux","link":"/blog/2021/06/01/%E5%88%86%E4%BA%AB%E4%B8%80%E4%BA%9B%E5%86%99%E7%9A%84%E5%BE%88%E5%A5%BD%E7%9A%84%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"react","slug":"react","link":"/blog/tags/react/"}],"categories":[]}